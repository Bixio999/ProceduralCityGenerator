using UnityEngine;

/*
 * Global goals rule.
 * 
 * Defines the most basic rule, which is often the base for more complex rules.
 * 
 * Assign the direction of a new road leading to the highest population density 
 * in the surrounding area.
 * 
 * From the initial direction, trace multiple directions within a certain angle 
 * and select the one with higher values.
 * 
 * The same strategy is applied to both highway and byway.
 */
public class BasicRule : IRoadMapRule
{
    // Number of directions to test
    protected int scanRays = 5; // Recommended value: 5

    // Scanning angle
    protected int scanAngle = 20; // Recommended value: 20

    /*
     * Calculate the direction within scanAngle that maximize the population density
     * value, from the given initial direction.
     */
    private Vector2 ScanForMaxPopulationDensity(Vector2 direction, Vector2 position, int length, in float[,] populationDensity)
    {
        Vector2 maxDirection = direction;
        float maxDensity = 0;

        // Compute the angles of the scans
        for (float i = - (float) this.scanAngle / 2; i < this.scanAngle / 2; i += (float) this.scanAngle / this.scanRays)
        {
            // Calculate the current scan direction
            Vector3 scanDir = Quaternion.AngleAxis(i, Vector3.up) * new Vector3(direction.x, 0, direction.y);
            Vector2 scanDirection = new Vector2(scanDir.x, scanDir.z);

            // Calculate the weight for the current scan direction as the sum of
            // the population density values in the values within the scan.

            Vector2 scanPosition;
            float weight = 0;

            for (int j = 0; j < length; j++)
            {
                // Calculate the current position along the scan direction
                scanPosition = position + scanDirection * j;

                // Check if the current position is in a valid position
                if (!InputMapGenerator.IsValidPosition(Mathf.RoundToInt(scanPosition.y), Mathf.RoundToInt(scanPosition.x), populationDensity.GetLength(0), populationDensity.GetLength(1)))
                    break;

                // Update the weight
                weight += populationDensity[Mathf.RoundToInt(scanPosition.y), Mathf.RoundToInt(scanPosition.x)] * (1 - ((float)j / length));
            }

            // Update the max weight and best direction
            if (weight > maxDensity)
            {
                maxDensity = weight;
                maxDirection = scanDirection;
            }
        }
        return maxDirection;
    }

    /*
     * Returns the road properties of a new highway.
     */
    public RoadAttributes GenerateHighway(RoadAttributes roadAttr, Crossroad start, in float[,] populationDensity)
    {
        roadAttr.direction = this.ScanForMaxPopulationDensity(roadAttr.direction, start.GetPosition(), roadAttr.length, populationDensity);
        return roadAttr;
    }

    /*
     * Returns the road properties of a new byway. 
     * 
     * As for the basic rule, byway are generated by the same strategy as the 
     * highway.
     */
    public RoadAttributes GenereateByway(RoadAttributes roadAttr, Crossroad start, in float[,] populationDensity)
    {
        return GenerateHighway(roadAttr, start, populationDensity);
    }
}